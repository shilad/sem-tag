package org.semtag.relate;

import com.typesafe.config.Config;
import org.apache.commons.lang3.ArrayUtils;
import org.semtag.dao.DaoException;
import org.semtag.dao.DaoFilter;
import org.semtag.dao.TagAppDao;
import org.semtag.model.Item;
import org.semtag.model.TagApp;
import org.semtag.model.TagAppGroup;
import org.semtag.model.concept.ConceptVector;
import org.wikapidia.conf.Configuration;
import org.wikapidia.conf.ConfigurationException;
import org.wikapidia.conf.Configurator;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * This class applies the methods from the Relator interface to items.
 * Unlike TagApps which rely directly on a single concept, items have
 * multiple concepts applied to them through their TagApps, so the
 * relatedness algorithms must be more complex.
 *
 * To calculate relatedness, it first gathers a concept vector space that
 * consists of all the concepts applied to both items in question. Next,
 * it generates a concept corelatedness matrix on that vector space for
 * later use. The vector space is then used to generate initial alpha
 * vectors of the items. Generally an alpha vector is a double[] the
 * length of the vector space where aX[n] is the amount of occurences in
 * item X of the nth concept in the vector space, though it can have
 * other meanings. The alpha vectors and matrix are then used to generate
 * beta vectors by multiplying the matrix times the alpha vectors. Finally,
 * cosine relatedness is calculated on the beta vectors and returned.
 *
 * To find most related items, it first gathers potentially related items.
 * This is done by gathering the most related concepts to the specified
 * item's concepts and gathering all items that have those concepts. It
 * then calculates the relatedness between the first item and each of the
 * gathered items and returns the ones with the highest relatedness score.
 * Here, rather than using the normal vector space described above, it
 * uses an aggregated vector space of all the gathered items so that it
 * only needs to generate one underlying concept corelatedness matrix.
 *
 * To calculate a corelatedness matrix, it runs a brute force algorithm
 * that manually calculates relatedness between each pair of items. Again,
 * rather than using the standard vector space, we use an aggregated
 * vector space so that only one underlying concept corelatedness matrix
 * must be generated. Only the one triangle of the matrix is actually
 * calculated, the other is copied from the one.
 *
 * In many situations, this class also allows ConceptVectors to be used
 * in place of items, as an item at its core is simply a vector of concepts.
 *
 * @author Ari Weiland
 */
public class ItemRelator implements Relator<Item> {

    private final TagAppDao helperDao;
    private final ConceptRelator relator;

    public ItemRelator(TagAppDao helperDao, ConceptRelator relator) {
        this.helperDao = helperDao;
        this.relator = relator;
    }

    public TagAppDao getHelperDao() {
        return helperDao;
    }

    public ConceptRelator getRelator() {
        return relator;
    }

    @Override
    public double relatedness(Item x, Item y) throws DaoException {
        if (x.equals(y)) {
            return 1;
        }
        int[] vectorSpace = getVectorSpace(x, y);
        double[][] matrix = relator.corelatedness(vectorSpace);
        return relatedness(x, y, vectorSpace, matrix);
    }

    /**
     * Returns the relatedness between two items within a given concept ID
     * vectorspace. The matrix MUST have been generated by a call to
     * ConceptRelator.corelatedness(vectorSpace), or else the result will
     * be meaningless.
     * @param x
     * @param y
     * @param vectorSpace
     * @param matrix
     * @return
     * @throws DaoException
     */
    public double relatedness(Item x, Item y, int[] vectorSpace, double[][] matrix) throws DaoException {
        TagAppGroup groupX = helperDao.getGroup(new DaoFilter().setItemId(x.getItemId()));
        TagAppGroup groupY = helperDao.getGroup(new DaoFilter().setItemId(y.getItemId()));
        int dim = vectorSpace.length;

        // convert to vector form
        double[] aX = new double[dim]; // alpha vector representation of groupX concepts in specified vector space
        double[] aY = new double[dim]; // alpha vector representation of groupY concepts in specified vector space
        for (int i=0; i<dim; i++) {
            for (TagApp t : groupX) {
                if (vectorSpace[i] == t.getConceptId()) {
                    aX[i]++;
                }
            }
            for (TagApp t : groupY) {
                if (vectorSpace[i] == t.getConceptId()) {
                    aY[i]++;
                }
            }
        }
        return cosineSimilarity(aX, aY, matrix);
    }

    /**
     * Returns the relatedness between a concept ID vector and an item.
     * Not really intended for use outside of this class.
     * @param vector
     * @param item
     * @return
     * @throws DaoException
     */
    public double relatedness(ConceptVector vector, Item item) throws DaoException {
        ConceptVector space = new ConceptVector(vector);
        space.addAll(vector.getVectorSpace());
        int[] vectorSpace = space.getVectorSpace();
        double[][] matrix = relator.corelatedness(vectorSpace);
        return relatedness(vector, item, vectorSpace, matrix);
    }

    /**
     * Returns the relatedness between a concept ID vector and an item.
     * Not really intended for use outside of this class.
     * The matrix MUST have been generated by a call to
     * ConceptRelator.corelatedness(vectorSpace), or else the result will
     * be meaningless.
     * @param vector
     * @param item
     * @param vectorSpace
     * @param matrix
     * @return
     * @throws DaoException
     */
    public double relatedness(ConceptVector vector, Item item, int[] vectorSpace, double[][] matrix) throws DaoException {
        TagAppGroup group = helperDao.getGroup(new DaoFilter().setItemId(item.getItemId()));
        int dim = vectorSpace.length;

        // convert to alpha vector form
        double[] aX = new double[dim]; // alpha vector representation of vector concepts in specified vector space
        double[] aY = new double[dim]; // alpha vector representation of item concepts in specified vector space
        for (int i=0; i<dim; i++) {
            for (int id : vector.getVectorSpace()) {
                if (vectorSpace[i] == id) {
                    aX[i] += vector.get(id);
                }
            }
            for (TagApp t : group) {
                if (vectorSpace[i] == t.getConceptId()) {
                    aY[i]++;
                }
            }
        }
        return cosineSimilarity(aX, aY, matrix);
    }

    /**
     * Private cosine similarity method defines how ItemRelator calculates
     * cosine similarity for two alpha vectors and a given matrix.
     * @param aX
     * @param aY
     * @param matrix
     * @return
     */
    private double cosineSimilarity(double[] aX, double[] aY, double[][] matrix) {
        int dim = aX.length;
        double xDotX = 0.0;
        double yDotY = 0.0;
        double xDotY = 0.0;
        for (int i=0; i<dim; i++) {
            // calculate beta vector values
            double bX = 0;
            double bY = 0;
            for (int j=0; j<dim; j++) {
                bX += matrix[i][j] * aX[j];
                bY += matrix[i][j] * aY[j];
            }
            // calculate cosine similarity between beta vector values
            xDotX += bX * bX;
            yDotY += bY * bY;
            xDotY += bX * bY;
        }
        return xDotY / Math.sqrt(xDotX * yDotY);
    }

    @Override
    public RelatedResultList mostRelated(Item obj, int maxResults) throws DaoException {
        return mostRelated(obj, maxResults, 0);
    }

    @Override
    public RelatedResultList mostRelated(Item obj, int maxResults, double threshold) throws DaoException {
        TagAppGroup group = helperDao.getGroup(new DaoFilter().setItemId(obj.getItemId()));
        ConceptVector vector = new ConceptVector();
        for (TagApp t : group) {
            vector.increment(t.getConceptId());
        }
        return mostRelated(vector, maxResults, threshold);
    }

    /**
     * Returns the most related items to an array of TagApps.
     * @param tagApps
     * @param maxResults
     * @return
     * @throws DaoException
     */
    public RelatedResultList mostRelated(TagApp[] tagApps, int maxResults) throws DaoException {
        return mostRelated(tagApps, maxResults, 0);
    }

    /**
     * Returns the most related items to an array of TagApps that pass the threshold.
     * @param tagApps
     * @param maxResults
     * @return
     * @throws DaoException
     */
    public RelatedResultList mostRelated(TagApp[] tagApps, int maxResults, double threshold) throws DaoException {
        ConceptVector vector = new ConceptVector();
        for (TagApp t : tagApps) {
            vector.increment(t.getConceptId());
        }
        return mostRelated(vector, maxResults, threshold);
    }

    /**
     * Returns the most related items to a collection of TagApps.
     * @param tagApps
     * @param maxResults
     * @return
     * @throws DaoException
     */
    public RelatedResultList mostRelated(Collection<TagApp> tagApps, int maxResults) throws DaoException {
        return mostRelated(tagApps, maxResults, 0);
    }

    /**
     * Returns the most related items to a collection of TagApps that pass the threshold.
     * @param tagApps
     * @param maxResults
     * @return
     * @throws DaoException
     */
    public RelatedResultList mostRelated(Collection<TagApp> tagApps, int maxResults, double threshold) throws DaoException {
        ConceptVector vector = new ConceptVector();
        for (TagApp t : tagApps) {
            vector.increment(t.getConceptId());
        }
        return mostRelated(vector, maxResults, threshold);
    }

    /**
     * Returns the most related items to a concept vector.
     * @param vector
     * @param maxResults
     * @return
     * @throws DaoException
     */
    public RelatedResultList mostRelated(ConceptVector vector, int maxResults) throws DaoException {
        return mostRelated(vector, maxResults, 0);
    }

    /**
     * Returns the most related items to a concept vector that pass the threshold.
     * @param vector
     * @param maxResults
     * @return
     * @throws DaoException
     */
    public RelatedResultList mostRelated(ConceptVector vector, int maxResults, double threshold) throws DaoException {
        ConceptVector space = new ConceptVector();
        for (int id : vector.getVectorSpace()) {
            space.add(id);
            RelatedResultList conceptList = relator.mostRelated(id, maxResults);
            for (RelatedResult result : conceptList) {
                space.add(result.getIntId());
            }
        }
        int[] vectorSpace = space.getVectorSpace();
        double[][] matrix = relator.corelatedness(vectorSpace);
        Iterable<TagApp> iterable = helperDao.get(new DaoFilter().setConceptIds(vectorSpace));
        Map<String, Item> items = new HashMap<String, Item>();
        for (TagApp t : iterable) {
            items.put(t.getItem().getItemId(), t.getItem());
        }
        RelatedResultList list = new RelatedResultList(maxResults, threshold);
        for (Item item : items.values()) {
            list.add(new RelatedResult<Item>(item.getItemId(), item, relatedness(vector, item, vectorSpace, matrix)));
        }
        list.lock();
        return list;
    }

    @Override
    public double[][] corelatedness(Item[] objs) throws DaoException {
        int dim = objs.length;
        int[] vectorSpace = getVectorSpace(objs);
        double[][] matrix = relator.corelatedness(vectorSpace);
        double[][] output = new double[dim][dim];
        for (int i=0; i<dim; i++) {
            for (int j=0; j<=i; j++) {
                // For efficiency, only calculate corelatedness in the upper triangle of the matrix
                output[i][j] = relatedness(objs[i], objs[j], vectorSpace, matrix);
                output[j][i] = output[i][j];
            }
        }
        return output;
    }

    @Override
    public double[][] corelatedness(Item[] xObjs, Item[] yObjs) throws DaoException {
        int[] vectorSpace = getVectorSpace((Item[]) ArrayUtils.addAll(xObjs, yObjs));
        double[][] matrix = relator.corelatedness(vectorSpace);
        double[][] output = new double[xObjs.length][yObjs.length];
        for (int i=0; i<xObjs.length; i++) {
            for (int j=0; j<yObjs.length; j++) {
                output[i][j] = relatedness(xObjs[i], yObjs[j], vectorSpace, matrix);
            }
        }
        return output;
    }

    private int[] getVectorSpace(Item... items) throws DaoException {
        ConceptVector vectorSpace = new ConceptVector();
        for (Item item : items) {
            TagAppGroup group = helperDao.getGroup(new DaoFilter().setItemId(item.getItemId()));
            for (TagApp t : group.getTagApps()) {
                if (t.getConceptId() > -1) {
                    vectorSpace.add(t.getConceptId());
                }
            }
        }
        return vectorSpace.getVectorSpace();
    }

    public static class Provider extends org.wikapidia.conf.Provider<ItemRelator> {
        public Provider(Configurator configurator, Configuration config) throws ConfigurationException {
            super(configurator, config);
        }

        @Override
        public Class getType() {
            return ItemRelator.class;
        }

        @Override
        public String getPath() {
            return "sem-tag.related.item";
        }

        @Override
        public ItemRelator get(String name, Config config) throws ConfigurationException {
            if (!config.getString("type").equals("item")) {
                return null;
            }
            return new ItemRelator(
                    getConfigurator().get(TagAppDao.class, config.getString("tagAppDao")),
                    getConfigurator().get(ConceptRelator.class, config.getString("relator"))
            );
        }
    }
}
